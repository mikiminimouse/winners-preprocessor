# Лучшие практики использования Docling

**Дата создания:** 2025-12-24  
**Версия:** 1.0

## Обзор

Данный документ описывает лучшие практики использования библиотеки IBM Docling на основе анализа нашего кода и рекомендаций сообщества Docling.

---

## 1. Анализ текущей реализации

### 1.1. Правильные практики

#### ✅ Использование PipelineOptions

**Что правильно:**

```python
# Правильное создание PipelineOptions
pdf_opts = PdfPipelineOptions()
pdf_opts.do_ocr = True
pdf_opts.do_table_structure = True
options = PipelineOptions(pdf=pdf_opts)
```

**Почему правильно:**
- Использование конструктора `PipelineOptions(pdf=pdf_opts)` вместо прямого присваивания
- Соответствует Pydantic модели Docling

#### ✅ Автоматическое определение формата

**Что правильно:**

```python
# Docling автоматически определяет формат
document = converter.convert(str(file_path))
# Не передаем input_format как параметр convert()
```

**Почему правильно:**
- `DocumentConverter.convert()` не принимает `input_format` - формат определяется автоматически
- Docling использует сигнатуры файлов и расширения для определения формата

#### ✅ Тонкая обертка над DocumentConverter

**Что правильно:**

```python
# Минимальная логика, максимум делегирования Docling
converter = DocumentConverter(options)
document = converter.convert(file_path)
```

**Почему правильно:**
- Docling предоставляет высокоуровневый API
- Не нужно дублировать логику обработки
- Фокус на orchestration, а не на деталях обработки

#### ✅ Использование model_dump() для сериализации

**Что правильно:**

```python
if hasattr(document, "model_dump"):
    doc_dict = document.model_dump()
```

**Почему правильно:**
- Pydantic модели поддерживают `model_dump()`
- Правильная сериализация вложенных объектов
- Поддержка JSON serialization

### 1.2. Проблемные практики

#### ❌ Попытки установить несуществующие поля

**Что неправильно:**

```python
# ЭТО НЕ РАБОТАЕТ
options.do_caption_mentions = True  # ❌ Поле не существует
options.do_table_of_contents = True  # ❌ Поле не существует
```

**Почему неправильно:**
- `PipelineOptions` не имеет таких полей
- Эти настройки должны быть в `PdfPipelineOptions` или не поддерживаются

**Рекомендация:** Удалить эти присваивания из legacy конфигурации

#### ❌ Неправильное использование preserve_layout

**Что неправильно:**

```yaml
# В YAML template
docling:
  preserve_layout: true  # ❌ Это поле может не поддерживаться
  preserve_formatting: true  # ❌ Это поле может не поддерживаться
```

**Почему неправильно:**
- Эти параметры могут не быть частью официального API Docling
- Используются как комментарии, но не применяются

**Рекомендация:** Проверить официальную документацию Docling для правильных параметров

---

## 2. Best Practices от сообщества Docling

### 2.1. Инициализация DocumentConverter

#### Рекомендуемый подход

```python
from docling.document_converter import DocumentConverter
from docling.datamodel.pipeline_options import PipelineOptions, PdfPipelineOptions

# Для PDF с OCR
pdf_opts = PdfPipelineOptions()
pdf_opts.do_ocr = True
pdf_opts.do_table_structure = True
options = PipelineOptions(pdf=pdf_opts)
converter = DocumentConverter(options)

# Для нативных форматов (DOCX, XLSX)
options = PipelineOptions()  # Default options
converter = DocumentConverter(options)
```

**Наш код:** ✅ Соответствует best practices

### 2.2. Обработка документов

#### Рекомендуемый подход

```python
# Простой вызов convert()
result = converter.convert(file_path)

# Доступ к документу
document = result.document

# Экспорт в Markdown (если поддерживается)
markdown = document.export_to_markdown()  # Если метод доступен
```

**Наш код:** ✅ Используем правильный подход, но не используем встроенные методы экспорта Docling

**Рекомендация:** Проверить наличие встроенных методов экспорта в Docling (например, `export_to_markdown()`)

### 2.3. Обработка ошибок

#### Рекомендуемый подход

```python
try:
    result = converter.convert(file_path)
    document = result.document
except Exception as e:
    logger.error(f"Conversion failed: {e}")
    # Обработка ошибки
```

**Наш код:** ✅ Используем try-except, но можем улучшить обработку специфичных ошибок Docling

**Рекомендация:** Обрабатывать специфичные исключения Docling (например, `ConversionError`)

### 2.4. Конфигурация через PipelineOptions

#### Рекомендуемый подход

- Использовать `PipelineOptions` для настройки
- Использовать вложенные опции (`PdfPipelineOptions`, `VlmPipelineOptions`)
- Не пытаться установить несуществующие поля

**Наш код:** ✅ В основном правильно, но есть legacy код с неправильными полями

---

## 3. Использование Docling как готового vs пересобранного образа

### 3.1. Готовый образ (pip install docling)

#### Плюсы

1. **Простота установки:**
   ```bash
   pip install docling>=2.60.0
   ```

2. **Автоматические обновления:** Легко обновлять до новых версий

3. **Стабильность:** Протестированные версии от IBM

4. **Документация:** Официальная документация соответствует pip версии

5. **Сообщество:** Больше примеров и поддержки для pip версии

#### Минусы

1. **Ограниченная кастомизация:** Нельзя легко модифицировать внутреннюю логику

2. **Зависимости:** Много зависимостей (PyTorch, detectron2, и т.д.)

3. **Размер:** Большой размер установки

### 3.2. Пересобранный образ (Docker/Dockerfile)

#### Плюсы

1. **Кастомизация:** Можно модифицировать код Docling

2. **Контроль зависимостей:** Точный контроль версий всех зависимостей

3. **Оптимизация:** Можно оптимизировать образ для конкретных задач

4. **Изоляция:** Изолированная среда выполнения

#### Минусы

1. **Сложность поддержки:** Нужно поддерживать собственный образ

2. **Обновления:** Сложнее обновлять до новых версий

3. **Отладка:** Сложнее отлаживать проблемы

4. **Документация:** Может не соответствовать кастомизированной версии

### 3.3. Рекомендация

**Для нашего проекта: используем готовый образ (pip install)**

**Обоснование:**

1. ✅ Нам не требуется кастомизация внутренней логики Docling
2. ✅ Простота поддержки и обновлений
3. ✅ Соответствие официальной документации
4. ✅ Использование стандартного API

**Когда использовать пересобранный образ:**

- Требуется кастомизация моделей
- Нужна оптимизация для конкретного hardware
- Требуется интеграция с кастомными компонентами на уровне кода

---

## 4. Варианты использования Docling

### 4.1. Вариант 1: Минимальный (текущий)

**Описание:** Тонкая обертка над DocumentConverter

**Код:**
```python
converter = DocumentConverter(options)
document = converter.convert(file_path)
```

**Плюсы:**
- Простота
- Минимум кода
- Легко поддерживать

**Минусы:**
- Ограниченный контроль
- Нет оптимизаций

### 4.2. Вариант 2: С кэшированием

**Описание:** Добавление кэширования результатов

**Код:**
```python
# Проверка кэша
file_hash = calculate_file_hash(file_path)
cached = get_cached_result(file_hash)
if cached:
    return cached

# Обработка
document = converter.convert(file_path)
save_to_cache(file_hash, document)
```

**Плюсы:**
- Ускорение повторной обработки
- Экономия ресурсов

**Минусы:**
- Дополнительная сложность
- Управление кэшем

**Статус:** Частично реализовано в `archive/docling/processor.py`

### 4.3. Вариант 3: С batch обработкой

**Описание:** Обработка нескольких документов одновременно

**Код:**
```python
# Docling поддерживает batch через DocumentConverter
results = converter.convert_batch(file_paths)
```

**Плюсы:**
- Эффективность
- Параллелизация

**Минусы:**
- Требует больше памяти
- Сложнее обработка ошибок

**Статус:** Не реализовано (есть только последовательная обработка)

### 4.4. Вариант 4: С VLM интеграцией

**Описание:** Использование VLM для улучшения OCR

**Код:**
```python
vlm_opts = VlmPipelineOptions()
vlm_opts.endpoint = os.environ.get("VLM_ENDPOINT")
options.vlm = vlm_opts
converter = DocumentConverter(options)
```

**Плюсы:**
- Улучшенное качество OCR
- Поддержка сложных документов

**Минусы:**
- Требует внешний VLM сервис
- Медленнее и дороже

**Статус:** Частично реализовано (через environment variables)

### 4.5. Рекомендация для нашего проекта

**Текущий вариант (минимальный) + улучшения:**

1. ✅ Оставить минимальную обертку (простота)
2. ➕ Добавить обработку специфичных ошибок Docling
3. ➕ Рассмотреть batch обработку для массовой обработки
4. ➕ Добавить кэширование (опционально, через MongoDB)

---

## 5. Сравнение с ранними наработками

### 5.1. archive/docling/processor.py

**Подход:**
- Монолитный класс `DocumentProcessor`
- Интеграция с MongoDB для кэширования
- Поддержка Cloud.ru VLM и S3
- Обработка метрик и сохранение в MongoDB

**Отличия от текущей реализации:**

1. **Кэширование:** Есть кэширование через MongoDB
2. **Метрики:** Детальные метрики обработки
3. **VLM:** Интеграция с Cloud.ru VLM
4. **S3:** Поддержка Cloud.ru S3

**Рекомендации:**

- ➕ Взять идею кэширования (опционально)
- ➕ Взять идею метрик (для мониторинга)
- ❌ Не использовать монолитный подход (текущий модульный подход лучше)

### 5.2. presort_root_files/docling/enhanced_pdf_smoldocling_processor.py

**Подход:**
- Комбинирование Docling и SmolDocling
- Двухэтапная обработка (локальный Docling → SmolDocling)
- Создание улучшенных изображений

**Отличия:**

1. **Гибридный подход:** Docling для предобработки, SmolDocling для финальной обработки
2. **Оптимизация изображений:** Создание улучшенных изображений для VLM

**Рекомендации:**

- ❌ Слишком сложно для текущих требований
- ➕ Идею оптимизации изображений можно использовать при необходимости

---

## 6. Рекомендации по улучшению

### 6.1. Использование встроенных методов экспорта

**Текущий подход:**
```python
# Мы создаем собственные экспортеры
export_to_markdown(document, output_path)
```

**Рекомендуемый подход:**
```python
# Проверить наличие встроенных методов
if hasattr(document, "export_to_markdown"):
    markdown = document.export_to_markdown()
```

**Рекомендация:** Исследовать встроенные методы экспорта Docling

### 6.2. Обработка специфичных ошибок

**Текущий подход:**
```python
except Exception as e:
    logger.error(f"Conversion failed: {e}")
```

**Рекомендуемый подход:**
```python
from docling.exceptions import ConversionError

try:
    document = converter.convert(file_path)
except ConversionError as e:
    # Специфичная обработка ошибок конвертации
except Exception as e:
    # Общая обработка ошибок
```

**Рекомендация:** Импортировать и обрабатывать специфичные исключения Docling

### 6.3. Оптимизация производительности

**Текущий подход:** Последовательная обработка

**Рекомендация:** Рассмотреть batch обработку или параллелизацию

```python
# Batch обработка (если поддерживается)
results = converter.convert_batch(file_paths)

# Или параллелизация через multiprocessing
from multiprocessing import Pool
with Pool(processes=4) as pool:
    results = pool.map(process_unit, unit_paths)
```

### 6.4. Использование правильных параметров

**Рекомендация:** Проверить официальную документацию Docling для всех параметров

- Удалить неподдерживаемые параметры из legacy конфигурации
- Использовать только валидные поля `PipelineOptions`

---

## 7. Заключение

### Что мы делаем правильно

1. ✅ Используем правильную инициализацию `PipelineOptions`
2. ✅ Автоматическое определение формата
3. ✅ Тонкая обертка над DocumentConverter
4. ✅ Правильная сериализация через `model_dump()`

### Что нужно улучшить

1. ➕ Удалить неподдерживаемые параметры из legacy конфигурации
2. ➕ Проверить встроенные методы экспорта Docling
3. ➕ Обрабатывать специфичные исключения Docling
4. ➕ Рассмотреть batch обработку для производительности

### Рекомендуемый подход

**Продолжать использовать готовый pip пакет** с минимальной оберткой, но:
- Улучшить обработку ошибок
- Оптимизировать производительность
- Использовать правильные параметры API

---

**Следующий документ:** [REFACTORING_AND_IMPROVEMENTS.md](REFACTORING_AND_IMPROVEMENTS.md) - проблемы и рекомендации по рефакторингу
