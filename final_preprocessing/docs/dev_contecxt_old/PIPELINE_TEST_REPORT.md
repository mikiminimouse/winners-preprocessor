# Отчет о тестировании Pipeline PaddleOCR-VL

## Цель

Проверить корректность использования pipeline из официального образа и отладить обработку изображений с таблицами на русском языке.

## Что сделано

### 1. Обновлен `server.py`

#### Изменения в `process_with_paddleocr()`:
- ✅ Добавлено детальное логирование каждого этапа
- ✅ Правильная обработка результата (может быть list, iterator, или одиночный объект)
- ✅ Соответствие официальной документации: `pipeline = PaddleOCRVL()`, `output = pipeline.predict(image_path)`

#### Изменения в `save_results_locally()`:
- ✅ Официальный способ сохранения: `for res in output: res.save_to_markdown/json()`
- ✅ Обработка множественных результатов (если pipeline возвращает list)
- ✅ Fallback на альтернативные методы при ошибках

#### Добавлен эндпоинт `/logs`:
- ✅ Возвращает последние логи (для отладки)
- ✅ Попытка чтения из journalctl или файла логов
- ✅ Информация о том, как получить логи через контейнер runtime

### 2. Создан тестовый скрипт `test_pipeline_basic.py`

Скрипт для проверки базового pipeline:
- Тест 1: Официальный способ (как в документации)
- Тест 2: С явными параметрами
- Проверка доступных методов результата
- Тестирование сохранения markdown/json

## Как использовать

### Запуск теста pipeline локально (в контейнере):

```bash
cd /root/winners_preprocessor
python3 paddle_docker_servise/test_pipeline_basic.py
```

### Тестирование через API:

```bash
# Тест обработки изображения с таблицей
curl -X POST "https://<your-url>/ocr" \
  -H "x-api-key: <API_KEY>" \
  -F "file=@test_images/page_0001 (3).png" \
  -F "return_content=true"

# Получение логов
curl -X GET "https://<your-url>/logs?limit=50" \
  -H "x-api-key: <API_KEY>"
```

## Официальный способ использования (документация)

Согласно официальной документации PaddleOCR-VL:

```python
from paddleocr import PaddleOCRVL

# 1. Инициализация
pipeline = PaddleOCRVL()

# 2. Обработка изображения
output = pipeline.predict("image_path.png")

# 3. Сохранение результатов
for res in output:
    res.print()
    res.save_to_json(save_path="output")
    res.save_to_markdown(save_path="output")
```

## Текущая реализация

### Инициализация (соответствует официальной):
```python
paddle_ocr = PaddleOCRVL()  # ✅ Официальный способ
```

### Обработка (соответствует официальной):
```python
result = ocr.predict(str(image_path))  # ✅ Официальный способ
```

### Сохранение (соответствует официальной):
```python
# Обрабатываем результаты (может быть list)
results_list = results if isinstance(results, list) else [results]
for res in results_list:
    res.save_to_markdown(save_path=temp_dir)  # ✅ Официальный способ
    res.save_to_json(save_path=temp_dir)      # ✅ Официальный способ
```

## Проверка корректности

### ✅ Соответствие официальной документации:
- Используется `PaddleOCRVL()` без параметров (использует дефолты из образа)
- Используется `pipeline.predict(image_path)`
- Используются официальные методы `save_to_markdown()` и `save_to_json()`

### ✅ Улучшения для отладки:
- Детальное логирование каждого этапа
- Обработка разных типов результатов (list, iterator, одиночный объект)
- Эндпоинт `/logs` для получения логов удаленно
- Fallback методы при ошибках

## Следующие шаги

1. **Пересобрать образ** с обновленным `server.py`
2. **Протестировать** обработку `test_images/page_0001 (3).png`
3. **Проверить логи** через `/logs` эндпоинт
4. **Сравнить результаты** с официальным demo

## Ожидаемые проблемы и решения

### Проблема 1: Результат - не list
**Решение**: Добавлена обработка разных типов результатов

### Проблема 2: save_to_markdown сохраняет в директорию, а не в файл
**Решение**: Создаем временную директорию, читаем созданный файл, объединяем результаты

### Проблема 3: Нет доступа к логам
**Решение**: Добавлен эндпоинт `/logs` (лучше использовать docker logs/kubectl logs)

## Примечания

- Pipeline использует официальный способ из документации
- Все методы соответствуют официальному API
- Улучшено логирование для отладки
- Добавлена обработка edge cases (разные типы результатов)

